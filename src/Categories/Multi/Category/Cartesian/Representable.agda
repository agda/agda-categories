{-# OPTIONS --without-K --safe #-}

module Categories.Multi.Category.Cartesian.Representable where

open import Data.List using (List; []; _∷_; _++_)
open import Data.List.Membership.Propositional using (_∈_)
open import Data.List.Membership.Propositional.Properties
  using (∈-++⁺ˡ; ∈-++⁺ʳ; ∈-++⁻)
open import Data.List.Relation.Unary.Any using (here; there)
import Data.List.Relation.Unary.Any.Properties as AnyP
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_]′)
open import Data.Wrap
open import Function.Base as F using (case_return_of_)
open import Level using (Level; _⊔_)
open import Relation.Binary.PropositionalEquality as ≡ using (_≡_)

open import Categories.Category
open import Categories.Category.BinaryProducts using (BinaryProducts)
open import Categories.Category.Cartesian
open import Categories.Category.Cartesian.Bundle
import Categories.Category.Cartesian.Properties as ×P
open import Categories.Multi.Category.Cartesian
open import Categories.Object.Terminal using (Terminal)

private
  variable
    o ℓ e : Level

module Extras {a} {A : Set a} where
  -- TODO: contribute to stdlib

  ∈-++⁺ : ∀ {x : A} {xs ys} (i : x ∈ xs ⊎ x ∈ ys) → x ∈ xs ++ ys
  ∈-++⁺ = [ ∈-++⁺ˡ , ∈-++⁺ʳ _ ]′

  ∈-++⁻∘++⁺ˡ : ∀ {x : A} {xs} ys (i : x ∈ xs) → ∈-++⁻ xs {ys} (∈-++⁺ˡ i) ≡ inj₁ i
  ∈-++⁻∘++⁺ˡ {xs = xs} ys i = AnyP.++⁻∘++⁺ xs (inj₁ i)

  ∈-++⁻∘++⁺ʳ : ∀ {x : A} xs {ys} (i : x ∈ ys) → ∈-++⁻ xs (∈-++⁺ʳ xs i) ≡ inj₂ i
  ∈-++⁻∘++⁺ʳ xs i = AnyP.++⁻∘++⁺ xs (inj₂ i)

  ∈-++⁺∘++⁻ : ∀ {x : A} xs {ys} (i : x ∈ xs ++ ys) → ∈-++⁺ (∈-++⁻ xs i) ≡ i
  ∈-++⁺∘++⁻ xs i = AnyP.++⁺∘++⁻ xs i

-- The *represented* Cartesian multicategories are those generated from a
-- Cartesian category by `Rep`. A multimorphism of type `Γ ⇒ A` is a morphism
-- of type `prod Γ ⇒ A` from the original category.

module _ {C : Category o ℓ e} (cart : Cartesian C) where

  open Category C
  open Equiv
  open HomReasoning
  open Cartesian cart
  open Terminal terminal
  open BinaryProducts products
  open ×P C
  open Prods cart

  infix 4 _⇒Π_ _≈Π_

  -- A map of type `X ⇒ prod Δ` is equivalently
  -- a map of type `X ⇒ Y` for each Y ∈ Δ.
  -- `X ⇒Π Δ` is exactly the latter.

  _⇒Π_ : Obj → List Obj → Set (o ⊔ ℓ)
  X ⇒Π Δ = Env (X ⇒_) Δ

  _≈Π_ : ∀ {X Δ} (fs gs : X ⇒Π Δ) → Set (o ⊔ e)
  _≈Π_ = [ _≈_ ]_≈ᵉ_

  ⟨_⟩Π : ∀ {X Δ} → X ⇒Π Δ → X ⇒ prod Δ
  ⟨_⟩Π {Δ = []} fs = !
  ⟨_⟩Π {Δ = Y ∷ Δ} fs = ⟨ fs (here ≡.refl) , ⟨ fs F.∘ there ⟩Π ⟩

  ⟨_⟩Π-resp-≈ : ∀ {X Δ} {fs gs : X ⇒Π Δ} → fs ≈Π gs → ⟨ fs ⟩Π ≈ ⟨ gs ⟩Π
  ⟨_⟩Π-resp-≈ {Δ = []} ps = refl
  ⟨_⟩Π-resp-≈ {Δ = Y ∷ Δ} ps =
    ⟨⟩-cong₂ (ps .get (here ≡.refl)) ⟨ [ ps .get F.∘ there ] ⟩Π-resp-≈

  projectΠ : ∀ {X Y Δ} (i : Y ∈ Δ) (fs : X ⇒Π Δ) → π[ i ] ∘ ⟨ fs ⟩Π ≈ fs i
  projectΠ (here ≡.refl) fs = project₁
  projectΠ (there i) fs =
    trans assoc (trans (∘-resp-≈ refl project₂) (projectΠ i _))

  ⟨π⟩Π : ∀ {Γ} → ⟨ π[_] {_} {Γ} ⟩Π ≈ id
  ⟨π⟩Π {Γ} = uniqueness* {ys = Γ} λ i → trans (projectΠ i _) (sym identityʳ)

  Rep : CartesianMultiCategory o ℓ e
  Rep = record
    { Obj = Obj
    ; _⇒_ = λ Γ A → prod Γ ⇒ A
    ; _≈_ = _≈_
    ; id = π[_]
    ; _∘_ = λ f σ → f ∘ ⟨ σ ⟩Π
    ; equiv = equiv
    ; ∘-resp-≈ = λ ff σσ → ∘-resp-≈ ff ⟨ σσ ⟩Π-resp-≈
    ; identityˡ = λ {_ _ _ i} → projectΠ i _
    ; identityʳ = λ {Γ} → trans (∘-resp-≈ʳ (⟨π⟩Π {Γ})) identityʳ
    ; assoc = λ {Γ Δ Θ A f σ τ} → Rep-assoc Γ Δ Θ A f σ τ
    }
    where
    _R⇒_ : List Obj → Obj → Set ℓ
    Γ R⇒ A = prod Γ ⇒ A

    _R⇒ˢ_ : (Γ Δ : List Obj) → Set (o ⊔ ℓ)
    _R⇒ˢ_ Γ = Env (Γ R⇒_)

    Rep-assoc-inner : ∀ Γ Δ Θ A (σ : Δ R⇒ˢ Θ) (τ : Γ R⇒ˢ Δ) (i : A ∈ Θ) →
      π[ i ] ∘ ⟨ σ ⟩Π ∘ ⟨ τ ⟩Π ≈ π[ i ] ∘ ⟨ (λ j → σ j ∘ ⟨ τ ⟩Π) ⟩Π
    Rep-assoc-inner Γ Δ Θ A σ τ i = begin
      π[ i ] ∘ ⟨ σ ⟩Π ∘ ⟨ τ ⟩Π  ≈⟨ sym-assoc ⟩
      (π[ i ] ∘ ⟨ σ ⟩Π) ∘ ⟨ τ ⟩Π  ≈⟨ projectΠ i _ ⟩∘⟨refl ⟩
      σ i ∘ ⟨ τ ⟩Π  ≈˘⟨ projectΠ i _ ⟩
      π[ i ] ∘ ⟨ (λ j → σ j ∘ ⟨ τ ⟩Π) ⟩Π  ∎

    Rep-assoc : ∀ Γ Δ Θ A (f : Θ R⇒ A) (σ : Δ R⇒ˢ Θ) (τ : Γ R⇒ˢ Δ) →
      (f ∘ ⟨ σ ⟩Π) ∘ ⟨ τ ⟩Π ≈ f ∘ ⟨ (λ i → σ i ∘ ⟨ τ ⟩Π) ⟩Π
    Rep-assoc Γ Δ Θ A f σ τ = begin
      (f ∘ ⟨ σ ⟩Π) ∘ ⟨ τ ⟩Π  ≈⟨ assoc ⟩
      f ∘ (⟨ σ ⟩Π ∘ ⟨ τ ⟩Π)
        ≈⟨ refl⟩∘⟨ uniqueness* {ys = Θ} (Rep-assoc-inner Γ Δ Θ _ σ τ) ⟩
      f ∘ ⟨ (λ i → σ i ∘ ⟨ τ ⟩Π) ⟩Π  ∎

-- The *free* Cartesian category generated by a Cartesian multicategory is the
-- category in which objects are lists of objects from the multicategory, and
-- morphisms are given by _⇒ˢ_ (simultaneous maps, a multimap for each object
-- in the codomain).
-- If the multicategory is given by the syntax of a simple type theory, with
-- `Γ ⇒ A` being the set of *terms* of type `A` in context `Γ`, then the free
-- Cartesian category is the category of contexts and simultaneous
-- substitutions.

module _ (CM : CartesianMultiCategory o ℓ e) where
  open CartesianMultiCategory CM
  open Equiv
  open Equivˢ

  Free : CartesianCategory o (o ⊔ ℓ) (o ⊔ e)
  Free = record
    { U = record
      { Obj = List Obj
      ; _⇒_ = _⇒ˢ_
      ; _≈_ = _≈ˢ_
      ; id = idˢ
      ; _∘_ = _∘ˢ_
      ; assoc = assocˢ
      ; sym-assoc = symˢ assocˢ
      ; identityˡ = identityˡˢ
      ; identityʳ = identityʳˢ
      ; identity² = identityˡˢ
      ; equiv = record { refl = reflˢ ; sym = symˢ ; trans = transˢ }
      ; ∘-resp-≈ = ∘ˢ-resp-≈
      }
    ; cartesian = record
      { terminal = record
        { ⊤ = []
        ; ⊤-is-terminal = record { ! = λ () ; !-unique = λ { σ .get () } }
        }
      ; products = record
        { product = λ {Γ Δ} → record
          { A×B = Γ ++ Δ
          ; π₁ = λ i → id (∈-++⁺ˡ i)
          ; π₂ = λ i → id (∈-++⁺ʳ Γ i)
          ; ⟨_,_⟩ = λ σ τ i → [ σ , τ ]′ (∈-++⁻ Γ i)
          ; project₁ = λ { .get i →
            trans identityˡ (reflexive (≡.cong [ _ , _ ]′ (∈-++⁻∘++⁺ˡ Δ i))) }
          ; project₂ = λ { .get i →
            trans identityˡ (reflexive (≡.cong [ _ , _ ]′ (∈-++⁻∘++⁺ʳ Γ i))) }
          ; unique = unique
          }
        }
      }
    }
    where
    open Extras

    unique : ∀ {Γ Δ Θ} {f : Θ ⇒ˢ (Γ ++ Δ)} {g : Θ ⇒ˢ Γ} {h : Θ ⇒ˢ Δ} →
      (λ j → id (∈-++⁺ˡ j)) ∘ˢ f ≈ˢ g →
      (λ k → id (∈-++⁺ʳ Γ k)) ∘ˢ f ≈ˢ h →
      (λ i → [ g , h ]′ (∈-++⁻ Γ i)) ≈ˢ f
    unique {Γ} p q .get i with ∈-++⁻ Γ i | ∈-++⁺∘++⁻ Γ i
    ... | inj₁ j | ≡.refl = trans (sym (p .get j)) identityˡ
    ... | inj₂ k | ≡.refl = trans (sym (q .get k)) identityˡ
